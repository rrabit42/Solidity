# 1. Making the Zombie Factory  
좀비 공장을 만들면서 배운 내용 기록  

### Version Pragma  
모든 솔리디티 소스 코드는 "version pragma"로 시작해야 함.  
이는 해당 코드가 이용해야 하는 솔리디티 버전을 선언하는 것. 이를 통해 이후에 새로운 컴파일러 버전이 나와도 기존 코드가 깨지지 않도록 예방.  

### 자료형  
#### 상태 변수 & 정수  
* 상태 변수: 컨트랙트 저장소에 영구적으로 저장. 즉, 이더리움 블록체인에 기록됨. 데이터베이스에 데이터를 쓰는 것과 동일.  

```
contract Example {
  // 이 변수는 블록체인에 영구적으로 저장된다
  uint myUnsignedInteger = 100;
}
```

> 참고:  
> 솔리디티에서 uint는 실제로 uint256, 즉 256비트 부호 없는 정수의 다른 표현.  
> uint8, uint16, uint32 등과 같이 uint를 더 적은 비트로 선언할 수도 있음.  

#### 연산  
* 덧셈: x + y  
* 뺄셈: x - y  
* 곱셈: x * y  
* 나눗셈: x / y  
* 모듈로 / 나머지: x % y (이를테면, 13 % 5는 3이다. 왜냐면 13을 5로 나누면 나머지가 3이기 때문이다)  

#### 구조체  
좀 더 복잡한 자료형  
```
struct Person {
  uint age;
  string name;
}
```

#### 배열  
솔리디티에는 정적 배열, 동적 배열이라는 두 종류의 배열이 있음  

```
// 2개의 원소를 담을 수 있는 고정 길이의 배열:
uint[2] fixedArray;
// 또다른 고정 배열으로 5개의 스트링을 담을 수 있다:
string[5] stringArray;
// 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있다:
uint[] dynamicArray;
// 구조체 배열
Person[] people; // 이는 동적 배열로, 원소를 계속 추가할 수 있다.
```
상태 변수가 블록체인에 영구적으로 저장될 수 있다는 걸 기억하나?  
그러니 이처럼 구조체의 동적 배열을 생성하면 마치 데이터베이스처럼 컨트랙트에 구조화된 데이터를 저장하는 데 유용.  

* public 배열  
public으로 배열을 선언 가능. 솔리디티는 이런 배열을 위해 getter 메소드를 자동적으로 생성.  
```
Person[] public people;
```
그러면 다른 컨트랙트들이 이 배열을 읽을 수 있게 됨.(쓸 수는 없음). 이는 컨트랙트에 공개 데이터를 저장할 때 유용한 패턴.  

### 함수 선언  
```
function eatHamburgers(string _name, uint _amount) {

}
```
참고: 함수 인자명을 언더스코어(_)로 시작해서 전역 변수와 구별하는 것이 관례 (의무는 아님).  


### 구조체와 배열 활용  
```
// 새로운 사람을 생성한다:
Person satoshi = Person(172, "Satoshi");

// 이 사람을 배열에 추가한다:
people.push(satoshi);

// 이 두 코드 조합하여
people.push(Person(16, "Vitalik"));
```

### Private / Public 함수  
솔리디티에서 함수는 기본적으로 public으로 선언됨. 즉, 누구나(혹은 다른 컨트랙트가) 나의 컨트랙트의 함수를 호출하고 코드를 실행할 수 있다는 의미.  
공격에 취약한 위험이 있음. 따라서 기본적으로 함수를 private으로 선언하고, 공개할 함수만 public으로 선언한는 것이 권장됨.  
```
uint[] numbers;

function _addToArray(uint _number) private {
  numbers.push(_number);
}
```
**private**은 컨트랙트 내의 다른 함수들만이 이 함수를 호출하여 numbers 배열로 무언가를 추가할 수 있다는 것 의미.  
private 키워드는 함수명 다음에 적기. 함수 인자명과 마찬가지로 함수명도 언더바(_)로 시작하는 것이 관례.  

### 함수 더 알아보기  
함수를 선언할 때 반환값 종류도 포함해야 함. 아래의 경우는 string.
```
string greeting = "What's up dog";

function sayHello() public returns (string) {
  return greeting;
}
```  
위에서 살펴 본 함수 sayHello()는 솔리디티에서 상태를 변화시키지 않음. 즉, 어떤 값을 변경하거나 무언가를 쓰지 않음.  
이 경우에는 함수를 **view 함수**로 선언한다! 이는 함수가 데이터를 보기만 하고 변경하지 않는다는 뜻!  
```function sayHello() public view returns (string) {```. 

솔리디티는 **pure**함수도 가지고 있는데 이는 함수가 앱에서 어떠한 데이터도 접근하지 않는 것을 의미  
```
function _multiply(uint a, uint b) private pure returns (uint) {
  return a*b
}
```  
> 참고: 함수를 pure나 view로 언제 표시할 지 기억하기 어려울 수 있음. 걱정마! 솔리디티 컴파일러가 어떤 제어자를 써야 하는지 경고 메세지를 통해 잘 알려줌!  

### Keccack256과 형 변환  
이더리움은 SHA3의 한 버전인 keccak256 를 내장 해시 함수로 가지고 있음.  
해시 함수는 기본적으로 입력 스트링을 랜덤 256비트 16진수로 매핑.  
스트링에 약간의 변화라도 있으면 해시 값은 크게 달라짐.  
해시 함수는 이더리움에서 여러 용도로 활용되지만, 여기서는 의사 난수 발생기(pseudo-random number generator)로 이용함.  

> 참고: 블록체인에서 안전한 의사 난수 발생기는 매우 어려운 문제.  
> 여기서 우리가 활용한 방법은 안전하지는 않지만, 좀비 DNA에 있어서 보안은 최우선순위가 아니니 우리의 목적에는 충분히 적합할 것. ~~그치만 나는 보안학과인걸~~  

* 자료형 간의 변환이 필요한 경우  
```
uint8 a = 5;
uint b = 6;
// a * b가 uint8이 아닌 uint를 반환하기 때문에 에러 메시지가 난다:
uint8 c = a * b; 
// b를 uint8으로 형 변환해서 코드가 제대로 작동하도록 해야 한다:
uint8 c = a * uint8(b); 
```  

### 이벤트  
이벤트는 자네의 컨트랙트가 블록체인 상에서 자네 앱의 사용자 단에서 무언가 액션이 발생했을 때 의사소통하는 방법.  
컨트랙트는 특정 이벤트가 일어나는지 "귀를 기울이고" 그 이벤트가 발생하면 행동을 취함.  
```
// 이벤트를 선언한다
event IntegersAdded(uint x, uint y, uint result);

function add(uint _x, uint _y) public {
  uint result = _x + _y;
  // 이벤트를 실행하여 앱에게 add 함수가 실행되었음을 알린다:
  IntegersAdded(_x, _y, result);
  return result;
}
```  
그러면 우리 앱의 사용자 단은 해당 이벤트가 일어나는지 귀를 기울임.  

자바스크립트로 이를 구현하면 다음과 같다:  
```
YourContract.IntegersAdded(function(error, result) {
  // 결과와 관련된 행동을 취한다
})
```

### Web3.js  
솔리디티 컨트랙트가 완성되었으면 이 컨트랙트와 상호작용하는 사용자단의 자바스크립트 코드를 완성해야한다.  
이더리움은 Web3.js라고 하는 자바스크립트 라이브러리를 가지고 있음.  

Web3.js가 구축된 컨트랙트와 어떤 방식으로 상호작용 하는가!  
```
// 여기에 우리가 만든 컨트랙트에 접근하는 방법을 제시한다:
var abi = /* abi generated by the compiler */
var ZombieFactoryContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// `ZombieFactory`는 우리 컨트랙트의 public 함수와 이벤트에 접근할 수 있다.

// 일종의 이벤트 리스너가 텍스트 입력값을 취한다:
$("#ourButton").click(function(e) {
  var name = $("#nameInput").val()
  // 우리 컨트랙트의 `createRandomZombie`함수를 호출한다:
  ZombieFactory.createRandomZombie(name)
})

// `NewZombie` 이벤트가 발생하면 사용자 인터페이스를 업데이트한다
var event = ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  generateZombie(result.zombieId, result.name, result.dna)
})

// 좀비 DNA 값을 받아서 이미지를 업데이트한다
function generateZombie(id, name, dna) {
  let dnaStr = String(dna)
  // DNA 값이 16자리 수보다 작은 경우 앞 자리를 0으로 채운다
  while (dnaStr.length < 16)
    dnaStr = "0" + dnaStr

  let zombieDetails = {
    // 첫 2자리는 머리의 타입을 결정한다. 머리 타입에는 7가지가 있다. 그래서 모듈로(%) 7 연산을 하여
    // 0에서 6 중 하나의 값을 얻고 여기에 1을 더해서 1에서 7까지의 숫자를 만든다. 
    // 이를 기초로 "head1.png"에서 "head7.png" 중 하나의 이미지를 불러온다:
    headChoice: dnaStr.substring(0, 2) % 7 + 1,
    // 두번째 2자리는 눈 모양을 결정한다. 눈 모양에는 11가지가 있다:
    eyeChoice: dnaStr.substring(2, 4) % 11 + 1,
    // 셔츠 타입에는 6가지가 있다:
    shirtChoice: dnaStr.substring(4, 6) % 6 + 1,
    // 마지막 6자리는 색깔을 결정하며, 360도(degree)까지 지원하는 CSS의 "filter: hue-rotate"를 이용하여 아래와 같이 업데이트된다:
    skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360),
    eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360),
    clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360),
    zombieName: name,
    zombieDescription: "A Level 1 CryptoZombie",
  }
  return zombieDetails
}
```  
그런 다음, 우리의 자바스크립트 코드가 위의 zombieDetails에서 생성된 값을 받아 웹 브라우저 기반 자바스크립트의 마법과 같은 기능(우리는 Vue.js를 이용함)을 활용하여 이미지를 변경하고 CSS 필터를 적용함.  
이를 위한 코드를 이후의 레슨에서 살펴볼 것.  






